local config = require("tairiki.config")

local M = {}

--- Generates a standalone vim colors file in a split window, or writes it
--- to your user runtime path if `force` is given.
--- 
--- Can be used to improve startup time, or to not have to depend on
--- tairiki.nvim as a plugin to provide your colorscheme.
---
--- Examples:
---
--- ```lua
--- --- dump your customized theme (ie what `:color tairiki` gives)
--- dump.colors_file()
--- ```
---
--- ```lua
--- --- dump a specific palette with a custom name
--- dump.colors_file("tomorrow-night", false, { palette = "tomorrow" })
--- ```
---@param colors_name? string what to name the theme
--- Defaults to `"tairiki-" .. opts.palette` if not provided
---@param force? boolean whether to automatically save the generated file
--- When `true`, writes to `"{vim.fn.stdpath("config")}/colors/{colors_name}.lua"`
---@param opts? tairiki.Config tairiki config, see `tairiki.config.setup()`
--- Partial configs will be merged with the global config
function M.colors_file(colors_name, force, opts)
  opts = config.extend(opts)
  colors_name = colors_name or ("tairiki-" .. opts.palette)
  force = force or false

  local colors = require("tairiki.palette").load(opts.palette, opts)
  local groups = require("tairiki.groups").load(opts, colors)
  local bg_style = require("tairiki.palette").get_palette_bg_style(opts.palette)

  local lines = {
    "-- this file generated by tairiki.dump.colors_file()",
    'if vim.g.colors_name then vim.cmd "hi clear" end',
    "vim.o.termguicolors = true",
    ('vim.o.background = "%s"'):format(bg_style),
    ('vim.g.colors_name = "%s"'):format(colors_name),
  }

  -- todo dump with colors, making the generated file editable
  --    though that might be possible, easily
  -- table.insert(lines, "local c = {")
  -- for k, v in pairs(colors) do
  --   local _type = type(v)
  --   if _type == "string" then
  --     table.insert(lines, ('  %s = "%s"'):format(k, v))
  --   elseif _type == "table" then
  --   end
  -- end
  -- table.insert(lines, "}")

  table.insert(lines, "local h = vim.api.nvim_set_hl")
  local names = vim.tbl_keys(groups)
  table.sort(names)
  for _, name in ipairs(names) do
    local hl = groups[name]
    hl = type(hl) == "string" and { link = hl } or hl
    table.insert(
      lines,
      ('h(0,"%s",%s)'):format(name, vim.inspect(hl, { indent = "", newline = "" }))
    )
  end

  if force then
    local outpath = vim.fs.joinpath(vim.fn.stdpath("config"), "colors/")
    local outfile = vim.fs.joinpath(outpath, ("%s.lua"):format(colors_name))
    vim.fn.mkdir(outpath, "p")
    local f, err = io.open(outfile, "w")
    if not f then
      vim.notify("tairiki: " .. err, vim.log.levels.ERROR)
    else
      f:write(table.concat(lines, "\n"))
      f:close()
      vim.notify("tairiki: wrote colors file to " .. outfile)
    end
  else
    local buf = vim.api.nvim_create_buf(true, false)
    vim.api.nvim_open_win(buf, true, { split = "right" })
    vim.api.nvim_buf_set_lines(0, 0, -1, false, lines)
    vim.bo.ft = "lua"
  end
end

return M
